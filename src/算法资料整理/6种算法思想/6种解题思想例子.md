## 一、递归算法

- 直接或间接调用自身函数或方法
- 把问题分解成规模缩小的同类问题的子问题

### 实现一个 document.getElementById 功能

递归其实就是 深度优先遍历

#### 第1步：明确输入、输出

输入：DOM 树根节点，要寻找的 id="box"

输出：返回满足 id="box" 的子节点

```js
    function getElementById(node, id) {

    }
```

#### 第2步：寻找递归结束条件

```js
function getElementById(node, id) {

    // 当前结点不存在，说明已经到了叶子结点还没有找到目标节点，返回 null
    if (!node) {
        return null
    }

    // 当前结点的 id 符合查找条件，返回当前结点
    if (node.id === id) {
        return node
    }
}
```

#### 第3步：明确递归关系

```js
function getElementById(node, id) {
    // 当前结点不存在，说明已经到了叶子结点还没有找到目标节点，返回 null
    if (!node) {
        return null
    }

    // 当前结点的 id 符合查找条件，返回当前结点
    if (node.id === id) {
        return node
    }

    // 前结点的 id 不符合查找条件，继续查找它的每一个子结点
    for (let i = 0; i < node.childNodes.length; i++) {
        // 递归查找它的每一个子结点
        const found = getElementById(node.childNodes[i], id)
        if (found) {
            return found
        }
    }
    return null
}

```

完成...

## 二、分治算法

- 把问题拆分为多个相互独立、形式相同的子问题
- 分别计算子问题
- 分并结果

### 二分查找

#### 第1步：分解问题

选择数组的中间数，把数组分为大的一组和小的一组，2组相互独立

```js
function binarySearch(nums, target) {
    // low, mid, high 将数组分为2组
    let low = 0,
        high = nums.length,
        mid = Math.floor((low + high) / 2)
}
```

#### 第2步：解决子问题

查找数与中间数做对比

- 比中间数低，则去中间数左边的子数组查找
- 比中问数高，则去中间数右边的子数组查找
- 与中间数相等，直接返回结果

```js
function binarySearch (nums, target) {
    let low = 0,
        high = nums.length,
        mid = Math.floor((low + high) / 2)
        
    while(low <= high) {
        if (nums[mid] < target) {
            low = mid + 1
        } else if (num[mid] > target) {
            high = mid - 1
        } else {
            return mid
        }
    }

    return -1
}
```






