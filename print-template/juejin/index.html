<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>面试官： 来说一下如何串行执行多个Promise - 掘金</title>
  <link rel="stylesheet" href="./inline-style.css">
  <link rel="stylesheet" href="./style.css">
  <style>
    @page {
      /* margin-top: 0; */
      /* margin-bottom: 0 */
    }
  </style>

  <script>
  
    const title = `面试官： 来说一下如何串行执行多个Promise`
    setTimeout(() => {
      document.querySelector('.article-title').innerText = title
    })

  </script>
</head>

<body style="padding-top: 20px;">
  <h1 class="article-title"></h1>
  <div class="article-content">
    <div data-v-550e9bd2="" class="article-content" itemprop="articleBody">
      <div class="markdown-body html">
        <style>
          .markdown-body {
            word-break: break-word;
            line-height: 1.75;
            font-weight: 400;
            font-size: 16px;
            overflow-x: hidden;
            color: #333
          }

          .markdown-body h1,
          .markdown-body h2,
          .markdown-body h3,
          .markdown-body h4,
          .markdown-body h5,
          .markdown-body h6 {
            line-height: 1.5;
            margin-top: 35px;
            margin-bottom: 10px;
            padding-bottom: 5px
          }

          .markdown-body h1 {
            font-size: 24px;
            margin-bottom: 5px
          }

          .markdown-body h2,
          .markdown-body h3,
          .markdown-body h4,
          .markdown-body h5,
          .markdown-body h6 {
            font-size: 20px
          }

          .markdown-body h2 {
            padding-bottom: 12px;
            border-bottom: 1px solid #ececec
          }

          .markdown-body h3 {
            font-size: 18px;
            padding-bottom: 0
          }

          .markdown-body h6 {
            margin-top: 5px
          }

          .markdown-body p {
            line-height: inherit;
            margin-top: 22px;
            margin-bottom: 22px
          }

          .markdown-body img {
            max-width: 100%
          }

          .markdown-body hr {
            border: none;
            border-top: 1px solid #ddd;
            margin-top: 32px;
            margin-bottom: 32px
          }

          .markdown-body code {
            word-break: break-word;
            border-radius: 2px;
            overflow-x: auto;
            background-color: #fff5f5;
            color: #ff502c;
            font-size: .87em;
            padding: .065em .4em
          }

          .markdown-body code,
          .markdown-body pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace
          }

          .markdown-body pre {
            overflow: auto;
            position: relative;
            line-height: 1.75
          }

          .markdown-body pre>code {
            font-size: 12px;
            padding: 15px 12px;
            margin: 0;
            word-break: normal;
            display: block;
            overflow-x: auto;
            color: #333;
            background: #f8f8f8
          }

          .markdown-body a {
            text-decoration: none;
            color: #0269c8;
            border-bottom: 1px solid #d1e9ff
          }

          .markdown-body a:active,
          .markdown-body a:hover {
            color: #275b8c
          }

          .markdown-body table {
            display: inline-block !important;
            font-size: 12px;
            width: auto;
            max-width: 100%;
            overflow: auto;
            border: 1px solid #f6f6f6
          }

          .markdown-body thead {
            background: #f6f6f6;
            color: #000;
            text-align: left
          }

          .markdown-body tr:nth-child(2n) {
            background-color: #fcfcfc
          }

          .markdown-body td,
          .markdown-body th {
            padding: 12px 7px;
            line-height: 24px
          }

          .markdown-body td {
            min-width: 120px
          }

          .markdown-body blockquote {
            color: #666;
            padding: 1px 23px;
            margin: 22px 0;
            border-left: 4px solid #cbcbcb;
            background-color: #f8f8f8
          }

          .markdown-body blockquote:after {
            display: block;
            content: ""
          }

          .markdown-body blockquote>p {
            margin: 10px 0
          }

          .markdown-body ol,
          .markdown-body ul {
            padding-left: 28px
          }

          .markdown-body ol li,
          .markdown-body ul li {
            margin-bottom: 0;
            list-style: inherit
          }

          .markdown-body ol li .task-list-item,
          .markdown-body ul li .task-list-item {
            list-style: none
          }

          .markdown-body ol li .task-list-item ol,
          .markdown-body ol li .task-list-item ul,
          .markdown-body ul li .task-list-item ol,
          .markdown-body ul li .task-list-item ul {
            margin-top: 0
          }

          .markdown-body ol ol,
          .markdown-body ol ul,
          .markdown-body ul ol,
          .markdown-body ul ul {
            margin-top: 3px
          }

          .markdown-body ol li {
            padding-left: 6px
          }

          .markdown-body .contains-task-list {
            padding-left: 0
          }

          .markdown-body .task-list-item {
            list-style: none
          }

          @media (max-width:720px) {
            .markdown-body h1 {
              font-size: 24px
            }

            .markdown-body h2 {
              font-size: 20px
            }

            .markdown-body h3 {
              font-size: 18px
            }
          }
        </style>
        <p>最近接到了一次阿里的电话面试，问的问题都挺有意思的，而且看重的不仅仅是问题能否回答得上来，还得能明白背后的原理以及能否使用其他的方式实现</p>
        <h2 data-id="heading-0">题目</h2>
        <p>其中一个题很有印象，也很常见，题目： 如何串行执行多个Promise。</p>
        <p>这要换在平时，经常看些面经或写点代码也能答出来： 使用<code>Array.prototype.reduce</code>、使用<code>async + 循环 + await</code>、
          或者使用新出的<code>for await of</code></p>
        <p>面试官： 那你还能说出使用其他的方式来实现吗？ for await of 的规则如何？</p>
        <p>我： ... 卒</p>
        <h2 data-id="heading-1">挑战</h2>
        <p>好吧，我们今天的挑战就是用各种方式来实现这个需求， 为此，我准备了一段代码</p>
        <pre><code lang="js" class="copyable"><span><span>function</span> <span>delay</span>(<span>time</span>) </span>{
  <span>return</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =&gt;</span> {
    <span>console</span>.log(<span>`wait <span>${time}</span>s`</span>)
    setTimeout(<span><span>()</span> =&gt;</span> {
      <span>console</span>.log(<span>'execute'</span>);
      resolve()
    }, time * <span>1000</span>)
  })
}

<span>const</span> arr = [<span>3</span>, <span>4</span>, <span>5</span>];
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>一个封装的延迟函数，然后一个装有3,4,5的数组，需求就是在开始执行时依次等待3, 4, 5秒，并在之后打印对应输出</p>
        <pre><code lang="shell" class="copyable">wait 3s // 等待3s

execute
wait 4s // 等待4s

execute
wait 5s // 等待5s

execute
<span class="copy-code-btn">复制代码</span></code></pre>
        <h3 data-id="heading-2">方式1. reduce</h3>
        <pre><code lang="js" class="copyable">arr.reduce(<span>(<span>s, v</span>) =&gt;</span> {
  <span>return</span> s.then(<span><span>()</span> =&gt;</span> delay(v))
}, <span>Promise</span>.resolve())
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>比较简单和常见的方式</p>
        <h3 data-id="heading-3">方式2. async + 循环 + await</h3>
        <pre><code lang="js" class="copyable">(
  <span>async</span> <span><span>function</span> (<span></span>) </span>{
    <span>for</span> (<span>const</span> v <span>of</span> arr) {
      <span>await</span> delay(v)
    }
  }
)()
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>本质上使用了async/await的功能</p>
        <h3 data-id="heading-4">方式3. 普通循环</h3>
        <p>其实仔细想想方式1的本质是使用一个中间变量（上一次执行结果）来保存<code>链式Promise</code>, 那我们举一反三， 换别的循环也可以实现</p>
        <pre><code lang="js" class="copyable"><span>let</span> p = <span>Promise</span>.resolve()
<span>for</span> (<span>const</span> i <span>of</span> arr) {
  p = p.then(<span><span>()</span> =&gt;</span> delay(i))
}
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>理论上所有循环方式都能实现，只要找到一个保存<code>链式Promise</code>的地方，闭包也好，参数也好。</p>
        <p>其实使用while循环时遇到一些坑，例如这样写。</p>
        <pre><code lang="js" class="copyable"><span>let</span> i
<span>let</span> p = <span>Promise</span>.resolve()
<span>while</span> (i = arr.shift()) {
  p = p.then(<span><span>()</span> =&gt;</span> delay(i))
}
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>思路没啥问题，问题就在于i放在外层时实际上每次都被改动，这和一道经典的面试题一样</p>
        <pre><code lang="js" class="copyable"><span>for</span>(<span>var</span> i = <span>0</span>, i &lt; <span>5</span>, i++) {
  setTimeout(<span><span>()</span> =&gt;</span> {
    <span>console</span>.log(i)
  }, i * <span>1000</span>)
}
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>事实上他们都会输出5。所以对于while循环，我们需要在内部也保存一份，最后我改成这样，感觉有点蠢，不过也没想到其他办法</p>
        <pre><code lang="js" class="copyable"><span>let</span> i
<span>let</span> p = <span>Promise</span>.resolve()
<span>while</span> (i = arr.shift()) {
  <span>let</span> s = i
  p = p.then(<span><span>()</span> =&gt;</span> delay(s))
}
<span class="copy-code-btn">复制代码</span></code></pre>
        <h3 data-id="heading-5">方式4. 递归</h3>
        <p>这是面试官提供的思路，也提到了<code>koa</code>，其实<code>koa</code>自己也有研究，其中洋葱模型来自于<code>koa-compose</code>库。</p>
        <pre><code lang="js" class="copyable"><span><span>function</span> <span>dispatch</span>(<span>i, p = Promise.resolve(</span>)) </span>{
  <span>if</span> (!arr[i]) <span>return</span> <span>Promise</span>.resolve()
  <span>return</span> p.then(<span><span>()</span> =&gt;</span> dispatch(i + <span>1</span>, delay(arr[i])))
}
dispatch(<span>0</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
        <h3 data-id="heading-6">方式5. for await of</h3>
        <p>
          通过查阅了<code>for await of</code>的规则，其实<code>for await of</code>和<code>for of</code>规则类似，只需要实现一个内部<code>[Symbol.asyncIterator]</code>方法即可
        </p>
        <pre><code lang="js" class="copyable"><span><span>function</span> <span>createAsyncIterable</span>(<span>arr</span>) </span>{
  <span>return</span> {
    [<span>Symbol</span>.asyncIterator]() {
      <span>return</span> {
        <span>i</span>: <span>0</span>,
        next() {
          <span>if</span> (<span>this</span>.i &lt; arr.length) {
            <span>return</span> delay(arr[<span>this</span>.i]).then(<span><span>()</span> =&gt;</span> ({ <span>value</span>: <span>this</span>.i++, <span>done</span>: <span>false</span> }));
          }

          <span>return</span> <span>Promise</span>.resolve({ <span>done</span>: <span>true</span> });
        }
      };
    }
  }
}

(<span>async</span> <span><span>function</span> (<span></span>) </span>{
  <span>for</span> <span>await</span> (i <span>of</span> createAsyncIterable(arr)) { }
})();
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>先创建出一个可异步迭代对象，然后丢到<code>for await of</code>循环即可</p>
        <h3 data-id="heading-7">方式6. generator</h3>
        <pre><code lang="js" class="copyable"><span><span>function</span>* <span>gen</span>(<span></span>) </span>{
  <span>for</span> (<span>const</span> v <span>of</span> arr) {
    <span>yield</span> delay(v)
  }
}

<span><span>function</span> <span>run</span>(<span>gen</span>) </span>{
  <span>const</span> g = gen()

  <span><span>function</span> <span>next</span>(<span>data</span>) </span>{
    <span>const</span> result = g.next(data)
    <span>if</span> (result.done) <span>return</span> result.value
    result.value.then(<span><span>function</span>(<span>data</span>) </span>{
      next(data)
    })
  }

  next()
}

run(gen)
<span class="copy-code-btn">复制代码</span></code></pre>
        <p>先创建一个generator函数，然后再封装一个自执行run函数</p>
        <h2 data-id="heading-8">后记</h2>
        <p>一个合格的工程师： 能找到或写出市面上最主流的实现方式</p>
        <p>一个出色的工程师： 能明白其中的原理，并能举一反三，有自己的思考。</p>
        <p>与君共勉！</p>
      </div>
    </div>
  </div>
</body>
</html>